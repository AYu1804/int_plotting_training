---
title: "Plotly_worksheet"
author: "NHS-R community"
date: '`r Sys.Date()`'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(plotly)
library(rmarkdown)
library(echarts4r)
library(readr)

# load data
cases <- read_csv("covid_data.csv")
```

## Learning objectives
- What are interactive plots/graphs?
- When it’s appropriate to use interactive visualisations over static and vice versa
- Basic uses of plotly and echarts4r packages 
- How to refer to JS documentation to add extra functionality to your plots
- How to present your interactive plots in Rmarkdown documents or Shiny apps

## What are interactive plots?

An interactive charts allows the user to perform actions such as zooming, hovering over a marker to get values, choosing a variable to display and more. [Some examples here](https://r-graph-gallery.com/interactive-charts.html). 

Interactive plot libraries include "plotly", "highcharts", "echarts4r", "leaflet" for mapping, "networkD3" for network graphs, and more. We will be going through plotly and echarts4r today. 

![Interactive bar plot snapshot](www/slides1.PNG)

## When to use interactive plots

Static plots made using ggplot2 are easily customisable and can be used for most occasions. However, if you want any of the following, you may want to consider creating an interactive plot:

- If your plot has many data points/bars and you want the user to be able to see the exact values on hover
- If your plot has a lot of data you want to show and you want the viewer to interact with it for more detail instead of showing it all at once.
- If you want the viewer to be able to filter the plot by period or another variable
- If you want shared interactivity between several plots. 
- If you want to engage the viewer more with your graph by zooming in, taking a snapshot, etc. 
- They look impressive!

However, there are limitations as well.

- Interactive plot packages tend to be less customisable compared to ggplot2 
- Take up more space 
- Certain functionalities are hard to find in R documentation – many times you will have to refer to original JS documentation!
- Certain functionalities (e.g. buttons in plotly) bug easily although there are workarounds
- Can confuse the viewer if there is too much functionality

## How they work

As you might know, everything is built from JavaScript. 

R packages that produce interactive plots are all built on JavaScript. Take for example the most commonly used package – plotly. Graphs produced using the plotly package in R are powered by the JS library [plotly.js](https://plotly.com/javascript/) (likewise, echarts4r is powered by echarts.js) The functions within the package allows you to utilise the JS interface using R code. Because of this, rendering interactive graphs in static documents like .pdfs and .docx won’t work – it will only work if it is opened in a browser like .html documents, server-hosted shiny apps, and in your local RStudio viewer. 

![R code to plot diagram](www/slides2.png)

## Training instructions

All the data and scripts you need are in the project folder (either in RStudio Cloud or in this GitHub repo). The first part of this session will focus on plotly and the second will focus on echarts. 

worksheet.Rmd (this file!) is for you to fill in if you are following along. (recommended)
answersheet.Rmd contains all the code and answers as a reference.

Feel free to use the answer sheet if the session is going too quickly/you missed something! 

## ggplotly

Ggplotly is a function within the plotly package that converts a ggplot2 object into an interactive plotly object. This is good for occasional use, but I recommend creating the plotly object yourself using plotly! 

```{r ggplotly}
plot <- ggplot(iris, aes(x = Sepal.Length, y = Sepal.Width, color = Species)) +   geom_point()
ggplotly(plot)
```

## Plotly basics

Plotly's plotting structure is similar to ggplot in that it is based on layers. The plot_ly() function will call the initial layer and aesthetics of the plot and you can use add_trace() to add additional layers. The layout() function deals with labels, themes, and other cosmetics of the plot which makes it similar to ggplot2::theme(). 

NOTE: add_trace() is just a generalised function for adding layers. You can also use add_bars(), add_lines(), etc. if you want to be specific about the layering. 

**Simple line plot**
```{r plotly line1}
cases %>%    
filter(areaName == "England") %>%   
arrange(date) %>%   
plot_ly(x = ~date, y = ~caseRate,           
	type = "scatter", mode = "lines") 

```

**Grouped line plot**
```{r plotly line grouped}
cases %>%    
arrange(date) %>%   
plot_ly(x = ~date, y = ~caseRate, color = ~areaName,          
	type = "scatter", mode = "lines") 
```

**Bar plot**
```{r plotly bar plot}
cases %>%  
  filter(areaName == "England") %>% 
  arrange(date) %>% 
  plot_ly(x = ~date, y = ~newCasesByPublishDate, type = 'bar') 
```

**Adding line layer**
```{r plotly line and bar}
cases %>%   
filter(areaName == "England") %>%   
arrange(date) %>%   
plot_ly(x = ~date, y = ~newCasesByPublishDate, 
	type = "bar", name = "Daily cases") %>%   
add_trace(y = ~rollingAvg, name = "Rolling avg", 
	type = "scatter", mode = "lines")

# Or to be specific with layer types:
cases %>%   
filter(areaName == "England") %>%   
arrange(date) %>%   
plot_ly(x = ~date, y = ~newCasesByPublishDate, 
	type = "bar", name = "Daily cases") %>%   
add_lines(y = ~rollingAvg, name = "Rolling avg")
```

**Adding title and tooltip**
```{r plotly layout1}
cases %>% 
  filter(areaName == "England") %>% 
  arrange(date) %>% 
  plot_ly(x = ~date, y = ~newCasesByPublishDate, type = 'bar', name = "Daily cases") %>% 
  add_lines(y = ~rollingAvg, name = "Rolling avg") %>% 
  layout(title = "Positive cases over time", hovermode = "x unified")
```

**Modifying legends**
```{r plotly layout2}
cases %>% 
  filter(areaName == "England") %>% 
  arrange(date) %>% 
  plot_ly(x = ~date, y = ~newCasesByPublishDate, type = 'bar', name = "Daily cases") %>% 
  add_lines(y = ~rollingAvg, name = "Rolling avg") %>% 
  layout(title = "Positive cases over time", 
         hovermode = "x unified",
         legend = list(orientation = "h",
                       xanchor = "center", 
                       x = 0.5),
         xaxis = list(title = ""))
```

**Changing marker colour**
```{r plotly layout3}
cases %>% 
  filter(areaName == "England") %>% 
  arrange(date) %>% 
  plot_ly(x = ~date) %>% 
  add_bars(y = ~newCasesByPublishDate, name = "Daily cases", 
          marker = list(color = "#5694ca")) %>% 
  add_lines(y = ~rollingAvg, name = "Rolling avg", line = list(color = "#003078")) %>% 
  layout(title = "Positive cases over time", 
         hovermode = "x unified",
         legend = list(orientation = "h",
                       xanchor = "center", 
                       x = 0.5),
         xaxis = list(title = ""))
```

**Editing modebar**
```{r plotly modebar}
cases %>% 
  filter(areaName == "England") %>% 
  arrange(date) %>% 
  plot_ly(x = ~date, y = ~newCasesByPublishDate, type = 'bar', 
          name = "Daily cases", 
          marker = list(color = "#72ceff")) %>% 
  config(modeBarButtonsToRemove = c("zoomIn2d", "zoomOut2d", "select2d", "lasso2d"))

# refer here for a full list of modebar buttons: https://github.com/plotly/plotly.js/blob/master/src/components/modebar/buttons.js

```

**Exercise 1**

Using the 'cases' dataset given to you, make a bar plot showing daily COVID cases over time in England, with an additional line layer showing the rolling 7-day average over time. Name both layers - "Cases" and " 7-day av)". Finally, add a title. 

[Reference plot](https://coronavirus.data.gov.uk/details/cases?areaType=nation&areaName=England)

Recommended steps:
- Filter dataset to England
- Make first plotly layer with "newCasesByPublishDate" as y and date as x. Name the layer appropriately
- Add line layer with rollingAvg as y. Name the layer appropriately.
- Add title

BONUS: 
- Change the line colour to "#003078" 
- Change hovermode to "x unified"
- Move legend to the bottom. 

```{r exercise 1}


```

**Adding buttons and dropdowns**
To add this functionality you will need to utilise JS properties, so the R code will seem a bit more complicated, because we will be "creating" the button and menu structures. You will use lists objects a lot because it is the most complex R object that can contain multiple elements of multiple types. 

"restyle": modify data or data attributes
"relayout": modify layout attributes
"update": modify data and layout attributes

More guidance and example code here: 
https://plotly.com/r/custom-buttons/
https://plotly.com/r/reference/

In this example we will use restyle method to modify the "type" into either "bar" or "scatter"

```{r plotly buttons1}
# make buttons using lists. For this example we are using method = "restyle" 
button_list <- list(
  list(
    method = "restyle",
    args = list("type", "bar"),  # first button with label "Bar" that changes type to "bar"
    label = "Bar"
  ),
  list(
    method = "restyle",
    args = list("type", "scatter"), # second button with label "Scatter" that changes type to "scatter"
    label = "Scatter"
  ))

cases %>% 
  filter(areaName == "England") %>% 
  arrange(date) %>% 
  plot_ly(x = ~date, y = ~newCasesByPublishDate, type = "bar",
          name = "Cases") %>% 
  layout(updatemenus = list( # to add these buttons, use updatemenus arg
    list(
      type = "buttons", 
      y = 0.8,  #placement of buttons on y axis
      buttons = button_list # add in list that we created previously
    )
  ))
```

In this example we will use restyle method to modify a new element "transforms.value" into either "England" or "Hertfordshire". 

```{r plotly buttons2}
button_list <- list(
  list(
    method = "restyle",
    args = list("transforms[0].value", "England"),  # first button that transforms value to England
    label = "England"
  ),
  list(
    method = "restyle",
    args = list("transforms[0].value", "Hertfordshire"), # first button that transforms value to Hertfordshire
    label = "Herts"
  ))

cases %>% 
  arrange(date) %>% 
  plot_ly(x = ~date, y = ~newCasesByPublishDate, type = "bar",
          name = "Cases",
          transforms = list( # in order to access the "transforms[0].value" attribute, we must make one.
            list(
              type = "filter", # we want it to transform by filtering...
              target = ~areaName, # the areaName variable..
              operator = '=',  # by equaling..
              value = ~c("England", "Hertfordshire")))) %>% # either England or Hertfordshire. 
  layout(updatemenus = list(
    list(type = 'dropdown', # the updatemenus is a dropdown this time
         active = 0, # first option of England by default (javascript starts from 0 not 1)
         buttons = button_list))) # using the button list we made before
```

## Echarts4r basics


